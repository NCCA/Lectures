# Memory and Pointers
Jon Macey

jmacey@bournemouth.ac.uk

---

## Lets think about memory
- We can think of memory as a series of empty slots
- Each cell in the slot will hold 1 Byte
- To identify which cell something is in we need an identifier. 
- This is called a memory address
- This is allocated by the OS when we communicate with it that we need a memory slot

--

# Remember this?
- sizeof( data type)

```
sizeof(char)= 1 
sizeof(short int)= 2 
sizeof(int)= 4 
sizeof(long int)= 8 
unsigned versions
sizeof(unsigned char)= 1 
sizeof(unsigned short int)= 2 
sizeof(unsigned int)= 4 
sizeof(unsigned long int)= 8 
```

- this tells us how many 1 byte memory cells each data type uses

--

```
#include <iostream>
#include <cstdlib>
int main()
{
	std::cout<<"sizeof(char)="<<sizeof(char)<<'\n';
	std::cout<<"sizeof(short int)="<<sizeof(short int)<<'\n';
	std::cout<<"sizeof(int)="<<sizeof(int)<<'\n';
	std::cout<<"sizeof(long int)="<<sizeof(long int)<<'\n';
	std::cout<<"sizeof(float)="<<sizeof(float)<<'\n';
	std::cout<<"sizeof(double)="<<sizeof(double)<<'\n';
	std::cout<<"sizeof(void*)="<<sizeof(void*)<<'\n';
	std::cout<<"sizeof(int *)="<<sizeof(int *)<<'\n';
	return EXIT_SUCCESS;
}
```
<div>
<div id="mySlideLeft">
<pre><code>
sizeof(char)=1
sizeof(short int)=2
sizeof(int)=4
sizeof(long int)=8
sizeof(float)=4
sizeof(double)=8
</code></pre>
</div>
<div id="mySlideRight">
<img src="images/MemoryCells.svg" width="40%" height="60%">
</div>
</div>

--

# & the address operator
- Sometimes know as a reference operator will give us the memory address of the cell containing the value
- we can usually use & to print it out.

<div>
<div id="mySlideLeft">
<pre><code>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main()
{
	int i=0;
	char c='c';
	double d=1.0;
	float f=1.0;
	std::cout&lt;&lt;"i address is "&lt;&lt;&i&lt;&lt;'\n';
	std::cout&lt;&lt;"c address is "&lt;&lt;static_cast&lt;void *>(&c)&lt;&lt;'\n';
	std::cout&lt;&lt;"d address is "&lt;&lt;&d&lt;&lt;'\n';
	std::cout&lt;&lt;"f address is "&lt;&lt;&f&lt;&lt;'\n';
	return EXIT_SUCCESS;
}

</pre></code>
</div>
	<div id="mySlideRight">
		<pre><code>
address of i is 0x7fff52ebc72c
address of c is d
address of c is 0x7fff52ebc72b
address of d is 0x7fff52ebc720
address of f is 0x7fff52ebc71c
		</code></pre>
	</div>
</div>


[Demo](http://pythontutor.com/cpp.html#code=%23include%20%3Ccstdlib%3E%0A%23include%20%3Ciostream%3E%0Aint%20main%28%29%0A%7B%0A%20%20%20%20int%20i%3D0%3B%0A%20%20%20%20char%20c%3D'c'%3B%0A%20%20%20%20double%20d%3D1.0%3B%0A%20%20%20%20float%20f%3D1.0%3B%0A%20%20%20%20std%3A%3Acout%3C%3C%22i%20address%20is%20%22%3C%3C%26i%3C%3C'%5Cn'%3B%0A%20%20%20%20std%3A%3Acout%3C%3C%22c%20address%20is%20%22%3C%3Cstatic_cast%3Cvoid%20*%3E%28%26c%29%3C%3C'%5Cn'%3B%0A%20%20%20%20std%3A%3Acout%3C%3C%22d%20address%20is%20%22%3C%3C%26d%3C%3C'%5Cn'%3B%0A%20%20%20%20std%3A%3Acout%3C%3C%22f%20address%20is%20%22%3C%3C%26f%3C%3C'%5Cn'%3B%0A%20%20%20%20return%20EXIT_SUCCESS%3B%0A%7D&curInstr=0&mode=display&origin=opt-frontend.js&py=cpp&rawInputLstJSON=%5B%5D)

---

# Storage Areas
- When a program is executed three storage areas are created called segments.
- Text / Code Segment :- used for the machine code / program instructions including functions.
- Data Segment (Data + Block Started Symbol + Heap)
- The Stack Segment :-  used for all variables / function variables executed in main

--

<img src="images/memory.svg" width="50%">

--

# [Text / Code segment](https://en.wikipedia.org/wiki/Code_segment)
- This is where the machine code generated by the compiler lives
- It  is a fixed size (size of our program) and generally read only
- Usually if an attempt is made to modify data in this segment the program will core dump
- It is possible to make this “position independent” for use in shared libraries / DLL’s

--

# [Data Segment BSS](https://en.wikipedia.org/wiki/Data_segment)
- Block Started by Symbol
- This is where [global](https://www.learncpp.com/cpp-tutorial/introduction-to-global-variables/) (declared outside main) data that is not assigned a value is stored
- Also any data prefixed with [static](https://www.learncpp.com/cpp-tutorial/static-local-variables/) and not assigned a default value
- By default this is assigned zero unless given a default value

--

# Data Segment
- Any data that either global or static but has a pre-defined value is allocated in the data segment

<div class="stretch">
<iframe width="1299" height="600px" src="https://godbolt.org/e#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlICsupVs1qhkAUgBMAISnTSAZ0ztkBPHUqZa6AMKpWAVwC2tEJNJb0AGTy1MAOWMAjTMTMA2UgAdUCwuto9QxMzb19/Ohs7RyMXN0lPJRU1OgYCZmICIONTcyTMVQC0jIIoh2dXD0V0zOyQvJrS23LYyoSASkVUA2JkDgByKQBmW2RDLABqcSGddQUCYkxmI2nscQAGAEFh0fHMKZnkefRWPCdVje2t2wIJ4FZUJzZOaYARF6HZa/o7h6fWSTTL6bebMNTICZUB5giYABQAkm8hgA6HicKhAy6XG6Q1CoCDtLEAdmBEzJE1B4ImOLwb0460xW3JE0WBB6tCmMjktM%2BxNe5Kx31uRmYtgJxOBGwAnJS8BCaW8GbymVN1jL0lScQAPRmbMmXfVq44gFDdAjTHQW%2B6PZ4Wi1gQYAVh0tAdusN6vQJrQBnNMytfzYgP9Mzdztdg2VetVnu9ZrtMwRCZ0YZdbqjHuNpt9yZ5ltDTrTkdJMazPr9%2BZ0OpDKcLEfd5LL8ZrNHxhJrqfrGfJrPZE2r0lV2yJr36nVYIH6jv6pFM/XWM9Qk8tXJkFO6vX2w04M4Ik4X7U6AGsQI71kJJ9wZ3OF6Ql/0ZwoQOe9/Ox6Q4LAkGgjF48OwyAoCAfz/ACQGAKVzCof8CFcJ8ICcfcZycWwMgAT0nHdSB/IwtAIAB5WhWAwt9SCwEVRHYJCyLwRZCgAN0wJ9SMwLUCl9AYsJuZRqNOJxiHQvQsEw3diDwIwRM6Gh6CYNgOB4fhBGEUQUDkOQhDOJ9IE6VAvBSWhmMfZQCn0zRtDqUxOAsbQyhiOJBB8Px9Ishzwn02yKjcKz8kKVJGhc7zjN82hikyDzWi86oSgCqKwuaOzKk4ToFA3PouHHSdp1naj7y1AAOdwAFp3G4O5kAhKVkUkCYIFwQgSE5IYrImPRf3/VxGqSlq1JkXckMPUgTzPC9%2BivbLSPvR9n1IV8Dwy/pJGvHLJz6t8BsY4g/A0bggA%3D%3D%3D"></iframe>


</div>

--

#[stack](https://en.wikipedia.org/wiki/Stack-based_memory_allocation)
- The [stack](https://www.learncpp.com/cpp-tutorial/the-stack-and-the-heap/) is where [local variables are allocated](https://www.learncpp.com/cpp-tutorial/local-variables/) (automatic variables)
- This is denoted by the { for scope
- The data is popped or pushed into the stack following the Last In First Out(LIFO) rule
- The stack is also used to hold information about functions such as return values and parameters passed (more later)
- We have little control over the stack

--

# [stack frames](https://en.wikipedia.org/wiki/Call_stack)
- When a program calls a function, the function and it’s arguments / return point are placed on a stack 
- The function being called may also need local variables to be created on the stack so it will store the initial stack pointer as a “frame pointer”

--


<img src="images/stack1.png" width="50%">

--

<img id="stack2" src="images/stack2.png" width="60%">

--

<img src="images/stack3.png" width="60%">


--

# Recursion
- A recursive function is a function that can call itself
- Typical examples are things like calculating factorials or traversing tree like structures
- It is possible to get a stack overflow using these types of functions
- Recursion doesn't always play nicely with the cache so it can cause performance issues

--


# [heap](https://en.wikipedia.org/wiki/Memory_management#DYNAMIC)
- The [heap](https://www.learncpp.com/cpp-tutorial/the-stack-and-the-heap/) is used for the programmer to define dynamic memory
- Data on the heap is anonymous (i.e. not linked to a variable) and the only way we can access it is via a memory address
- The programmer will then have to manage this data and is one of the most important parts of programming in a “non managed” language such as C/C++
- to manage this we use an abstraction called a pointer

---

# [What is a pointer](https://en.wikipedia.org/wiki/Pointer_(computer_programming)?

- It's a variable just like any other variable
- The pointer variable is defined by the asterisk * being placed before the variable name.
```
int *data;
```
- What did that just say ?
- Well the variable data is a pointer of type int.

--

# But why use Pointers?

- C and C++ allow the programmer to point into a program and at memory
- Pointers point to a memory address where a declared variable lives
- This allows us to create and manipulate dynamic data structures which can grow or shrink depending upon the program need.
- [It also lets us allocate memory dynamically within a program](https://www.learncpp.com/cpp-tutorial/dynamic-memory-allocation-with-new-and-delete/).

--

# Pointers and Arrays

> In C, there is a strong relationship between pointers and arrays, strong enough that pointers and arrays should be discussed simultaneously.  
Any operation that can be achieved by array subscripting can also be done with pointers. 
The pointer version will in general be faster but, at least to the uninitiated, somewhat harder to understand.” 

- [The C Programming Language K&R](https://en.wikipedia.org/wiki/The_C_Programming_Language)

--

# Pointers and Arrays

``` 
int a[10];
```
<img src="images/array1.png" width="100%">

--

# Pointers and Arrays

```
int *pa;
pa=&a[0];
```

- The assignment sets pa to point to element zero of a; that is, pa contains the address of a[0]. 
<img src="images/array2.png" width="100%">

--

# Pointers and Arrays

- In declarations, ```[ ]``` means ‘‘array of’’ and ```∗``` means ‘‘pointer to.’’ 
- The assignment
```c++
x=*pa;
```
- will copy the contents of a[0] into x.

--

# Pointers and Arrays
- If pa points to a particular element of an array, then by definition pa+1 points to the next element, pa+i points i elements after pa, and pa-i points i elements before. 
- Thus, if pa points to ```a[0]```,  ```*(pa+i)``` refers to the contents of ```a[1]```, ```pa+i``` is the address of ```a[i]```, and ```*(pa+i)``` is the contents of ```a[i]```. 
<img src="images/array3.png" width="100%">

--

# Pointers and Arrays

- a reference to a[i] can also be written as *(a+i). 
- In evaluating a[i], C converts it to *(a+i) immediately; the two forms are equivalent. 
- Applying the operator & to both parts of this equivalence, it follows that &a[i] and a+i are also identical: a+i is the address of the i-th element beyond a. 

--

# Variable Arithmetic
- Arithmetic on normal variables changes the value contained in the variable
- This is shown in the following table

| variable initializer | operation | result |
|--------------------|---------|------|
|```int i=0;```	|```i++;```	|```i=1```|
|```int i=5;```	|```i+=5;```	|```i=10```|
|```int i=10;```|	```i--;```	|```i=9```|
|```int i=10;```|	```i-=5;```	|```i=5```|

--

# [Pointer Arithmetic](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/ptrToArray.cpp)
- Arithmetic with pointers take the same form as with other variables as shown

```
#include <iostream>
#include <cstdlib>

int main()
{

	int intArray[5]={32,65,1,399,9324};

	int *ptrToArray;
	int *end;

	// as we are using an array we could use
	// ptrToArray=intArray; however the following is
	// more clear when getting the first element
	ptrToArray=&intArray[0];
	end=&intArray[5];
	while(ptrToArray !=end)
	{
		std::cout<<"value "<< *ptrToArray<<" address "<<ptrToArray<<'\n';
		// increment the pointer to next cell
		ptrToArray++;
	}
	return EXIT_SUCCESS;
}
```

--

#Output

```
value 32 address 0x7fff5495c240
value 65 address 0x7fff5495c244
value 1 address 0x7fff5495c248
value 399 address 0x7fff5495c24c
value 9324 address 0x7fff5495c250
```

- note the values increment by sizeof(int) and as stored in an array are contiguous

--

# is that all for pointers?

- no we are going to do lots more (including allocating memory)
- first we need to learn a few more things
- we will also look at C++ smart pointers

---

# [L-Values and R-Values](https://goo.gl/sWQRJd)
- Every C++ expression is either an [lvalue or an rvalue](https://www.learncpp.com/cpp-tutorial/value-categories-lvalues-and-rvalues/). 
- An lvalue refers to an object that persists beyond a single expression. You can think of an lvalue as an object that has a name. 
- All variables, including const variables, are lvalues. 
- An rvalue is a temporary value that does not persist beyond the expression that uses it. 
- To better understand the difference between lvalues and rvalues, consider the following example:

--

# [L-Values and R-Values](https://goo.gl/sWQRJd)

```
#include <iostream>
#include <cstdlib>

int main()
{
	int x=3+4;
	std::cout << x << '\n';
	return EXIT_SUCCESS;
}
```

- In this example x is an l-values as it persists beyond the definition
- 3+4 is an r-value as it evaluates temporarily before being assigned to the l-value x

--

# [L-Values and R-Values](https://msdn.microsoft.com/en-gb/library/f90831hc.aspx)

```
int main()
{
   int i, j, *p;

   // Correct usage: the variable i is an lvalue.
   i = 7;

   // Incorrect usage: The left operand must be an lvalue (C2106).
   7 = i; // C2106
   j * 4 = 7; // C2106

   // Correct usage: the dereferenced pointer is an lvalue.
   *p = i; 

   const int ci = 7;
   // Incorrect usage: the variable is a non-modifiable lvalue (C3892).
   ci = 9; // C3892

   // Correct usage: the conditional operator returns an lvalue.
   ((i < 3) ? i : j) = 7;
}
```
```
lvalues2.cpp:11:4: error: expression is not assignable
 7 = i; // C2106
 ~ ^
lvalues2.cpp:12:8: error: expression is not assignable
 j * 4 = 7; // C2106
 ~~~~~ ^
lvalues2.cpp:19:5: error: read-only variable is not assignable
 ci = 9; // C3892
 ~~ ^
```

--

## [References are Aliases not Pointers](http://www.haroldserrano.com/blog/c-tip-16-references-are-aliases-not-pointers)
- A reference is another name for an existing object.
	- They are not pointers!
	- There are no null references all references require initialisation

```
ref1.cpp:8:7: error: declaration of reference variable 'x' requires an initializer
        int &x;
             ^
1 error generated.
```

--

#& and C++

- In C++ the ```&``` is an explicit reference
- This means that the object passed using the & prefix is effectively a pointer but we are not using the * prefix as used in C
- In C++ ```*_a``` indicates that the value is a pointer and we may modify it in a function
- In C++ [```&_a```](https://www.learncpp.com/cpp-tutorial/pass-by-lvalue-reference/) is a reference (means we don’t copy the value) but still behaves like a pointer
- const [```&_a```](https://www.learncpp.com/cpp-tutorial/pass-by-const-lvalue-reference/) means that it is a constant reference to a value. This means it is copied like a pointer but is read only.

--

# [swap.c](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/swap.c)

```
#include <stdio.h>
#include <stdlib.h>


void swap(int *a, int *b)
{
	int tmp=*b;
	*b=*a;
	*a=tmp;
}

int main()
{
	int a=10;
	int b=20;
	printf("%d %d \n",a,b);
	swap(&a,&b);
	printf("%d %d \n",a,b);
}
```

--

#[swap.cpp](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/swap.c)

```
#include <iostream>
#include <cstdlib>

void swap(int &a, int &b)
{
	int tmp=b;
	b=a;
	a=tmp;
}

int main()
{
	int a=10;
	int b=20;
	std::cout<<a<<' '<<b<<'\n';
	swap(a,b);
	std::cout<<a<<' '<<b<<'\n';
	return EXIT_SUCCESS;
}

```

--

## [References are Aliases not Pointers](http://www.haroldserrano.com/blog/c-tip-16-references-are-aliases-not-pointers)


- A reference is an alias for an object that already exists prior to the initialisation of the reference
- Once a reference is initialised to refer to a particular object, it cannot later be made to refer to a different object;
- a reference is bound to the initialiser.

---

## [Dynamic memory Allocation](https://en.wikipedia.org/wiki/C_dynamic_memory_allocation)
- When we dynamically allocate memory in a C program we allocate to the heap.
- This means that the data will be persistent throughout the program lifetime.
- This means we have to manage this memory ourselves.
- As the OS allocates the memory for us it is possible that we can run out of memory  

--

# [mem2.c](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/mem2.c)

```
#include <stdio.h>
#include <stdlib.h>

int main()
{
	char *mem;
	mem=malloc(1844634744071325);
	free(mem);
	return EXIT_SUCCESS;
}
```

```
a.out(59967,0x7fffa4ea93c0) malloc: *** mach_vm_map(size=1844634744074240) failed (error code=3)
*** error: can't allocate region
*** set a breakpoint in malloc_error_break to debug
```

--

# [malloc](http://en.cppreference.com/w/cpp/memory/c/malloc)
- To allocate memory in C we use malloc (we can also use it in C++)
```
#include <stdlib.h> 
void * malloc(size_t size);
```
- This allocates size bytes of memory. 
- If the allocation succeeds, a pointer to the block of memory is returned.
- malloc returns a void pointer (void *), which indicates that it is a pointer to a region of unknown data type.
- NULL is returned if memory can’t be allocated

--

#[free](http://www.cplusplus.com/reference/cstdlib/free/)

- The memory created by malloc is persistent so needs to be cleared once finished with.
- This is done with the free function as follows

```
#include <stdlib.h> 
void free(void *ptr);

```
- The pointer must be passed to free only once; unless malloc has been re-called on the same pointer.

--

# [doublefree.c](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/doublefree.c)

```
#include <stdio.h>
#include <stdlib.h>

int main()
{
	char *mem;
	printf("%p\n",mem);
	mem=malloc(10);
	printf("%p\n",mem);
	// free mem
	free(mem);
	printf("%p\n",mem);
	// double free error
	free(mem);
	printf("%p\n",mem);
	return EXIT_SUCCESS;
}
```

```
a.out(39525) malloc: *** error for object 0x104a00840: pointer being freed was not allocated
*** set a breakpoint in malloc_error_break to debug
Abort trap: 6
```

--

# malloc / free
- The implementation of malloc is not guaranteed to initialise the memory to a set value 
- This can lead to security flaws where we can re-allocate memory and see previous values.
- In the case of the gcc implementation it seems that the values are set to a zero
- memory is always allocated contiguously so it can be accessed in the same way as an array as shown in the following example.

--

# [malloc2.c](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/malloc2.c)

```
#include <stdio.h>
#include <stdlib.h>


int main()
{
	float *mem;
	mem=(float*)malloc(20*sizeof(float));
	for (int i=0; i<20; ++i)
	{
		printf("%.1f \n",mem[i]);
	}
	printf("\n");
	// free up the memory
	free(mem);
	return EXIT_SUCCESS;
}

```

--


# [calloc](http://www.cplusplus.com/reference/cstdlib/calloc/)

- malloc does not initialise the memory (gcc however does seem to do so)
- The calloc function however is designed to both allocate memory and set it to zero.

```
#include <stdlib.h>
void *calloc(size_t count, size_t size);
```

- It allocates count bytes with size data type size

```
float *f =  calloc(20,sizeof(float));
```

--

# [realloc](http://en.cppreference.com/w/c/memory/realloc)

- The realloc function allows us to resize already allocated memory.
- We can shrink or grow this memory space

```
#include <stdlib.h>
void *realloc( void *ptr, size_t new_size );
```

- If realloc is unable to resize the memory region in-place, it allocates new storage then copies the required data. 
- The old pointer is then freed
- If realloc fails it returns a NULL but the original memory is unaffected

--

# [realloc.c](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/realloc.c)

```
#include <stdio.h>
#include <stdlib.h>

int main()
{
	int index=0;
	// allocate some memory
	char *alphabet = calloc(26,sizeof(char));
	char *more=calloc(26,sizeof(float));
	printf("\nalphabet %p \n",alphabet);
	printf("\nmore %p \n",more);

	for( char c='a'; c<='z'; ++c)
	{
		alphabet[index++]=c;
	}

	for(int i=0; i<26; ++i)
	{
		printf("%c ",alphabet[i]);
	}
	printf("\nrealloc %p \n",alphabet);
	alphabet=realloc(alphabet,26*2);
	printf("\nrealloc %p \n",alphabet);

	for( char c='A'; c<='Z'; ++c)
	{
		alphabet[index++]=c;
	}

	for(int i=0; i<26*2; ++i)
	{
		printf("%c ",alphabet[i]);
	}
	printf("\n");
  free(alphabet);
	return EXIT_SUCCESS;
}

```

--

# [memset](http://en.cppreference.com/w/c/string/byte/memset)

``` 
#include <string.h>
void *memset( void *dest, int ch, size_t count );
```

- The memset function set writes len bytes of value c (converted to an unsigned char) to string b
- It performs a byte to byte copy

--

#[memcpy](http://en.cppreference.com/w/c/string/byte/memcpy)

``` 
#include <string.h>
void* memcpy( void *dest, const void *src, size_t count );
```

- The memcpy function copies len bytes from memory area src to memory area dst.  
- If src and dst over-lap, behaviour is undefined. 

---

# C++ memory allocation
- so far we have looked at the C library memory allocation functions.
- there are also version in the C std library in C++

```
#include <cstdlib>
std::malloc()
std::free()
```

- we will also sometimes use malloc and free even in C++ (for example [overloading new](https://www.informit.com/guides/content.aspx?g=cplusplus&seqNum=40))

--

# [new / delete](https://www.learncpp.com/cpp-tutorial/dynamic-memory-allocation-with-new-and-delete/) 
```
int *data = new int [100];
```
- new is used to allocate new objects in C++, in this case we are constructing an array of int[] objects
- Once this has been done we can access the data as we would a normal array using the [] index operator
- All the normal rules of arrays apply
- Once we have finished with the memory allocated to the pointer we need remove it
- To do this we use the delete [] operation
- if we do not do this it could cause problems as we will see later

--

# [new.cpp](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/new.cpp)

```
#include <iostream>
#include <cstdlib>

int main()
{
	std::cout<<"enter size of the array\n";
	int size;
	std::cin>>size;

	int *mem= new int[size];
	for(int i=0; i<size; ++i)
		mem[i]=i;

	for(int i=0; i<size; ++i)
		std::cout<<mem[i]<<"\n";

	delete [] mem;

}
```

- note the explicit call to delete here 

---

# Pointers in modern C++

- One of the biggest problems in programming is managing the lifetime of objects.
- Automatic objects are easy because they are destroyed when they go out of scope.
- However it is not always possible to use automatic variables and we need to use pointers.
- One common error when using pointers is forgetting to deallocate them (i.e. call free or delete)

--

## [smart pointers and move semantics](https://www.learncpp.com/cpp-tutorial/introduction-to-smart-pointers-move-semantics/)

- C++ 11 introduced an number of smart pointers to help manage the lifetime of raw pointers.
- These should be preferred to using raw pointers.
- [#include &lt;memory&gt; ](http://en.cppreference.com/w/cpp/header/memory)
	- [std::unique_ptr&lt;T&gt; ](http://en.cppreference.com/w/cpp/memory/unique_ptr)
	- [std::shared_ptr&lt;T&gt; ](http://en.cppreference.com/w/cpp/memory/shared_ptr)
- are the most common useage patterns

--

# [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization)

- smart pointers are a form of “resource acquisition is initialisation”
- In C++  the only code that can be guaranteed to be executed after an exception is thrown are the dtors of objects residing on the stack.
- Resources are acquired during initialisation as there is no chance of them being used before they are available
- They are released during the destruction of the object

--

# [smartArray.cpp](https://github.com/NCCA/ASELectureCode/blob/master/Lecture3/smartArray.cpp)

```
#include <iostream>
#include <memory>
#include <cstdlib>
#include <algorithm>
#include <numeric>

int main()
{
  constexpr size_t size=10;

  std::unique_ptr<int  []> data ( new int [size]);
  std::iota(&data[0],&data[size],0);
  for(int i=0; i<size; ++i)
    std::cout<<data[i]<<'\n';
  return EXIT_SUCCESS;
}
```

--

# [make_unique (c++ 14)](http://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)

- [make_unique](https://www.learncpp.com/cpp-tutorial/stdunique_ptr/) allows us to create a unique_ptr without having to use new we should prefer this to using new.

```
#include <iostream>
#include <memory>
#include <cstdlib>
#include <algorithm>
#include <numeric>

// on mac use clang++ -std=c++14  -stdlib=libc++ makeUnique.cpp
int main()
{
  constexpr size_t size=10;

  std::unique_ptr<int  []> data = std::make_unique<int[]>(size);
  std::iota(&data[0],&data[size],0);
  for(int i=0; i<size; ++i)
    std::cout<<data[i]<<'\n';
  return EXIT_SUCCESS;
}
```

--

# self study

- [gotw-89 smart pointers](https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/)
- [new write new and delete again](http://scrupulousabstractions.tumblr.com/post/37576903218/cpp11style-no-new-delete)
 
<iframe width="560" height="315" src="https://www.youtube.com/embed/xnqTKD8uD64" frameborder="0" allowfullscreen></iframe>

---

#References
- Hanly. J. R Koffman E. B. 1999, Problem Solving & Program Design in C, 3rd Edition, Addison Wesley, International Ed
- Sebesta R. W. 2002, Concepts of Programming Languages, 5th edition, Addison Wesley, International Ed
- http://www.tenouk.com/ModuleZ.html
- http://www.akkadia.org/drepper/cpumemory.pdf

--

# further reading

- http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c


